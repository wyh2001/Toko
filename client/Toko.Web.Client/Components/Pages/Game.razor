@page "/game/{roomId}"
@using Toko.Shared.Models
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Toko.Web.Client.Services
@inject HttpClient Http
@inject NavigationManager Navigation
@inject IAuthenticationService AuthService
@inject IPlayerNameService PlayerNameService
@implements IAsyncDisposable
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@* @rendermode InteractiveWebAssembly *@

<PageTitle>Game - @roomName - Toko Toko</PageTitle>

<div class="game-container">
    <!-- Game Header -->
    <div class="game-header">
        <div class="game-title-section">
            <h1 class="game-title">@roomName</h1>
            <div class="game-subtitle">Racing Session ‚Ä¢ Round @((gameData?.CurrentRound ?? 0) + 1) / @(gameData?.TotalRounds ?? 0)</div>
        </div>
        <div class="game-controls">
            <button class="control-button" @onclick="ShowGameMenu">‚â° Menu</button>
            <button class="control-button danger" @onclick="LeaveGame">‚Üê Leave Game</button>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="loading-section">
            <div class="loading-message">Loading Game...</div>
        </div>
    }
    else if (gameData == null)
    {
        @if (gameEnded)
        {
            <div class="game-ended-section">
                <div class="game-ended-message">üèÅ Game Finished</div>
                <div class="game-ended-subtitle">The race has ended! Check the final results.</div>
                <div class="game-ended-actions">
                    <button class="action-button primary" @onclick="ViewRoom">View Room</button>
                    <button class="action-button secondary" @onclick="GoHome">Return Home</button>
                </div>
            </div>
        }
        else
        {
            <div class="error-section">
                <div class="error-message">Game Not Found</div>
                <div class="error-subtitle">The game may have ended or does not exist</div>
                <button class="action-button primary" @onclick="GoHome">Return Home</button>
            </div>
        }
    }
    else
    {
        @if (gameEnded || gameData?.Status == "Ended" || gameData?.Status == "Finished")
        {
            <!-- Game Ended State -->
            <div class="game-ended-overlay">
                <div class="game-ended-content">
                    <h2>üèÅ Race Finished!</h2>
                    <div class="final-results">
                        <h3>Final Results</h3>
                        @if (gameData?.Results != null)
                        {
                            <div class="results-list">
                                @foreach (var result in gameData.Results)
                                {
                                    <div class="result-item @(result.PlayerId == AuthService.PlayerId ? "current-player" : "")">
                                        <div class="result-position">#{@result.Rank}</div>
                                        <div class="result-name">@GetPlayerName(result.PlayerId).ToUpper()</div>
                                        <div class="result-score">Score: @result.Score</div>
                                    </div>
                                }
                            </div>
                        }
                    </div>
                    <div class="game-ended-actions">
                        <button class="action-button primary" @onclick="ViewRoom">View Room</button>
                        <button class="action-button secondary" @onclick="ReviewGame">Review Game</button>
                        <button class="action-button secondary" @onclick="GoHome">Return Home</button>
                    </div>
                </div>
            </div>
        }
        
        <!-- Main Game Layout -->
        <div class="game-layout">
            <!-- Left Panel - Players and Status -->
            <div class="left-panel">
                <!-- Game Status -->
                <div class="status-section">
                    <h3 class="panel-title">Game Status</h3>
                    <div class="status-grid">
                        <div class="status-item">
                            <div class="status-number">@((gameData?.CurrentRound ?? 0) + 1) / @(gameData?.TotalRounds ?? 0)</div>
                            <div class="status-label">Round</div>
                        </div>
                        <div class="status-item">
                            <div class="status-number">@((gameData?.CurrentStep ?? 0) + 1) / @(gameData?.TotalSteps ?? 0)</div>
                            <div class="status-label">Step</div>
                        </div>
                        <div class="status-item">
                            <div class="status-number">@(gameData?.Racers?.Count ?? 0)</div>
                            <div class="status-label">Players</div>
                        </div>
                        <div class="status-item">
                            <div class="status-text">@gamePhaseString</div>
                            <div class="status-label">Phase</div>
                        </div>
                    </div>
                </div>

                <!-- Players List -->
                <div class="players-section">
                    <h3 class="panel-title">Racers</h3>
                    <div class="players-list">
                        @if (gameData?.Racers != null)
                        {
                            @foreach (var player in gameData.Racers)
                            {
                            <div class="player-item @(player.Id == AuthService.PlayerId ? "current-player" : "") @(currentTurnPlayer == player.Id ? "active-turn" : "")">
                                <div class="player-info">
                                    <div class="player-name">@player.Name.ToUpper()</div>
                                    <div class="player-position">Position @GetPlayerPosition(player.Id)</div>
                                </div>
                                <div class="player-status">
                                    @if (currentTurnPlayer == player.Id)
                                    {
                                        <div class="turn-indicator">‚óè</div>
                                    }
                                    @if (player.IsHost)
                                    {
                                        <div class="host-badge">HOST</div>
                                    }
                                </div>
                            </div>
                            }
                        }
                    </div>
                </div>

                <!-- Game Log -->
                <div class="log-section">
                    <h3 class="panel-title">Game Log</h3>
                    <div class="log-container">
                        @foreach (var logEntry in gameLogs.TakeLast(10))
                        {
                            <div class="log-entry">
                                <div class="log-time">R@logEntry.Turn</div>
                                <div class="log-message">@logEntry.Message</div>
                            </div>
                        }
                    </div>
                </div>
            </div>

            <!-- Center Panel - Game Board -->
            <div class="center-panel">
                <div class="board-section">
                    <h3 class="panel-title">Race Track</h3>
                    <div class="race-board">
                        @for (int i = 0; i < 20; i++)
                        {
                            <div class="track-segment @(i == 0 ? "start" : "") @(i == 19 ? "finish" : "")">
                                <div class="segment-number">@i</div>
                                <div class="segment-racers">
                                    @foreach (var player in GetPlayersAtPosition(i))
                                    {
                                        <div class="racer-token @GetPlayerColorClass(player.Id)">
                                            @GetPlayerInitials(player.Name)
                                        </div>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>

            <!-- Right Panel - Hand and Actions -->
            <div class="right-panel">
                <!-- Current Hand -->
                <div class="hand-section">
                    <h3 class="panel-title">Your Hand (@playerHand.Count cards)</h3>
                    <div class="card-hand">
                        @foreach (var card in playerHand)
                        {
                            <div class="game-card @(GetCardSelectionClass(card))" 
                                 @onclick="() => HandleCardClick(card)">
                                <div class="card-type">@card.Type</div>
                                <div class="card-value">@GetCardValue(card.Type)</div>
                                @if (ShouldShowCardDisabledOverlay(card))
                                {
                                    <div class="card-disabled-overlay">
                                        <span>@GetCardDisabledMessage(card)</span>
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>

                <!-- Action Panel -->
                <div class="action-section">
                    <h3 class="panel-title">Actions</h3>
                    <div class="action-buttons">
                        @if (isMyTurn)
                        {
                            @if (gamePhase == Phase.CollectingCards)
                            {
                                <button class="action-button primary @(string.IsNullOrEmpty(selectedCard) ? "disabled" : "")"
                                        @onclick="PlaySelectedCard"
                                        disabled="@(string.IsNullOrEmpty(selectedCard))">
                                    Submit Card
                                </button>
                                <button class="action-button secondary" @onclick="DrawCards">
                                    Draw Cards
                                </button>
                            }
                            else if (gamePhase == Phase.CollectingParams)
                            {
                                <!-- Parameter Collection UI -->
                                <div class="param-collection-section">
                                    <div class="param-info">
                                        <strong>Card Type:</strong> @(gameData?.CurrentTurnCardType ?? "Unknown")
                                    </div>
                                    
                                    @if (gameData?.CurrentTurnCardType == "Move")
                                    {
                                        <div class="param-input">
                                            <label>Move Distance:</label>
                                            <div class="effect-buttons">
                                                <button class="effect-button @(moveEffect == 1 ? "selected" : "")" 
                                                        @onclick="() => SetMoveEffect(1)">1</button>
                                                <button class="effect-button @(moveEffect == 2 ? "selected" : "")" 
                                                        @onclick="() => SetMoveEffect(2)">2</button>
                                            </div>
                                        </div>
                                    }
                                    else if (gameData?.CurrentTurnCardType == "ChangeLane")
                                    {
                                        <div class="param-input">
                                            <label>Lane Direction:</label>
                                            <div class="effect-buttons">
                                                <button class="effect-button @(changeLaneEffect == -1 ? "selected" : "")" 
                                                        @onclick="() => SetChangeLaneEffect(-1)">‚Üê Left</button>
                                                <button class="effect-button @(changeLaneEffect == 1 ? "selected" : "")" 
                                                        @onclick="() => SetChangeLaneEffect(1)">Right ‚Üí</button>
                                            </div>
                                        </div>
                                    }
                                    else if (gameData?.CurrentTurnCardType == "Repair")
                                    {
                                        <div class="param-input">
                                            <label>Select Junk Cards to Discard:</label>
                                            <div class="repair-instruction">
                                                Click on Junk cards in your hand above to select them for discarding.
                                            </div>
                                        </div>
                                    }
                                    
                                    <button class="action-button primary @(IsParameterSubmissionReady() ? "" : "disabled")"
                                            @onclick="SubmitParameters"
                                            disabled="@(!IsParameterSubmissionReady())">
                                        Submit Parameters
                                    </button>
                                </div>
                            }
                            else if (gamePhase == Phase.Discarding)
                            {
                                <!-- Discarding Phase UI -->
                                <div class="discard-phase-section">
                                    <div class="discard-info">
                                        <strong>Discarding Phase</strong>
                                        <p>Click on cards in your hand to select them for discarding (Junk cards cannot be discarded)</p>
                                    </div>
                                    
                                    @if (IsPlayerInDiscardPhase())
                                    {
                                        <div class="discard-actions">
                                            <button class="action-button primary @(HasJunkCardsSelected() ? "disabled" : "")" 
                                                    @onclick="SubmitDiscardCards"
                                                    disabled="@HasJunkCardsSelected()">
                                                Discard Selected Cards (@selectedDiscardCards.Count)
                                            </button>
                                            <button class="action-button secondary" @onclick="SkipDiscard">
                                                Skip Discarding
                                            </button>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="waiting-discard-message">
                                            Waiting for other players to discard...
                                        </div>
                                    }
                                </div>
                            }
                            <button class="action-button" @onclick="EndTurn">
                                End Turn
                            </button>
                        }
                        else
                        {
                            @if (gamePhase == Phase.Discarding)
                            {
                                <!-- Show discard actions for all players in discard phase -->
                                @if (IsPlayerInDiscardPhase())
                                {
                                    <div class="discard-phase-section">
                                        <div class="discard-info">
                                            <strong>Discarding Phase</strong>
                                            <p>Click on cards in your hand to select them for discarding (Junk cards cannot be discarded)</p>
                                        </div>
                                        
                                        <div class="discard-actions">
                                            <button class="action-button primary @(HasJunkCardsSelected() ? "disabled" : "")" 
                                                    @onclick="SubmitDiscardCards"
                                                    disabled="@HasJunkCardsSelected()">
                                                Discard Selected Cards (@selectedDiscardCards.Count)
                                            </button>
                                            <button class="action-button secondary" @onclick="SkipDiscard">
                                                Skip Discarding
                                            </button>
                                        </div>
                                    </div>
                                }
                                else
                                {
                                    <div class="waiting-discard-message">
                                        <div class="waiting-message">
                                            Waiting for other players to discard...
                                        </div>
                                    </div>
                                }
                            }
                            else
                            {
                                <div class="waiting-message">
                                    Waiting for @GetPlayerName(currentTurnPlayer)...
                                </div>
                            }
                        }
                    </div>
                </div>

                <!-- Game Instructions -->
                <div class="instructions-section">
                    <h3 class="panel-title">Instructions</h3>
                    <div class="instructions-content">
                        @if (gamePhase == Phase.CollectingCards)
                        {
                            <p>Select a card to program your move. Each card represents a movement command.</p>
                        }
                        else if (gamePhase == Phase.CollectingParams)
                        {
                            @if (gameData?.CurrentTurnCardType == "Move")
                            {
                                <p>Choose how many spaces to move forward (1 or 2).</p>
                            }
                            else if (gameData?.CurrentTurnCardType == "ChangeLane")
                            {
                                <p>Choose which direction to change lanes (Left or Right).</p>
                            }
                            else if (gameData?.CurrentTurnCardType == "Repair")
                            {
                                <p>Click on Junk cards in your hand above to select them for discarding. You can select none to skip.</p>
                            }
                            else
                            {
                                <p>Submit parameters for your selected card.</p>
                            }
                        }
                        else if (gamePhase == Phase.Discarding)
                        {
                            @if (IsPlayerInDiscardPhase())
                            {
                                <p>Click on cards in your hand to select them for discarding. Junk cards cannot be discarded and will be grayed out.</p>
                            }
                            else
                            {
                                <p>Waiting for other players to finish discarding cards...</p>
                            }
                        }
                        else
                        {
                            <p>Waiting for game to start...</p>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string RoomId { get; set; } = string.Empty;

    private HubConnection? hubConnection;
    private Timer? pollingTimer;
    
    private bool isLoading = true;
    private RoomStatusSnapshot? gameData;
    private string roomName = "";
    private Phase gamePhase = Phase.CollectingCards;
    private string gamePhaseString = "CollectingCards";
    private string? currentTurnPlayer;
    private bool isMyTurn = false;
    private bool gameEnded = false;
    
    private List<CardDto> playerHand = new();
    private string selectedCard = "";
    private List<GameLogEntry> gameLogs = new();
    
    // Parameter collection state
    private int moveEffect = 1;
    private int changeLaneEffect = 1;
    private List<string> selectedJunkCards = new();
    private List<CardDto> junkCards = new();
    
    // Discarding phase state
    private List<string> selectedDiscardCards = new();
    private List<CardDto> discardableCards = new();

    protected override async Task OnInitializedAsync()
    {
        await AuthService.EnsureAuthenticatedAsync();
        await InitializeSignalR();
        await LoadGameData();
        
        // Load hand data from API
        await LoadHandData();
        
        // Start polling for game updates
        pollingTimer = new Timer(
            callback: async _ => {
                await LoadGameData();
                await LoadHandData();
            },
            state: null,
            dueTime: TimeSpan.Zero,
            period: TimeSpan.FromSeconds(3)
        );
    }

    private async Task LoadHandData()
    {
        try
        {
            // Only load hand data if game is playing
            if (gameData?.Status != "Playing") return;
            
            var response = await Http.GetFromJsonAsync<ApiSuccess<GetHandDto>>($"/api/room/{RoomId}/hand");
            
            if (response?.Data != null)
            {
                playerHand = response.Data.Cards;
                
                // Update junk cards for repair functionality
                junkCards = playerHand.Where(c => c.Type == "Junk").ToList();
                
                // Update discardable cards for discarding phase (exclude Junk cards)
                discardableCards = playerHand.Where(c => c.Type != "Junk").ToList();
                
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load hand data: {ex.Message}");
            // Don't clear the hand on error, just log it
        }
    }

    private async Task InitializeSignalR()
    {
        try
        {
            hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/racehub"))
                .WithAutomaticReconnect()
                .Build();
                
            hubConnection.On<string, object>("OnRoomEvent", (eventName, eventData) =>
            {
                Console.WriteLine($"Game event received: {eventName}");
                
                switch (eventName)
                {
                    case "PhaseChanged":
                        InvokeAsync(async () => {
                            await LoadGameData();
                            await LoadHandData();
                            StateHasChanged();
                        });
                        break;
                        
                    case "PlayerCardsDrawn":
                        InvokeAsync(async () => {
                            await LoadGameData();
                            await LoadHandData();
                            StateHasChanged();
                        });
                        break;
                        
                    case "PlayerCardsDiscarded":
                        InvokeAsync(async () => {
                            await LoadGameData();
                            await LoadHandData();
                            StateHasChanged();
                        });
                        break;
                        
                    case "PlayerStepExecuted":
                    case "RoundAdvanced":
                    case "StepAdvanced":
                        InvokeAsync(async () => {
                            await LoadGameData();
                            await LoadHandData();
                            StateHasChanged();
                        });
                        break;
                        
                    case "RoomEnded":
                        Console.WriteLine($"Game ended for room: {RoomId}");
                        InvokeAsync(async () => {
                            gameEnded = true;
                            pollingTimer?.Dispose(); // Stop polling when game ends
                            await LoadGameData(); // Load final game state
                            StateHasChanged();
                        });
                        break;
                        
                    case "PlayerJoined":
                    case "PlayerLeft":
                        InvokeAsync(async () => {
                            await LoadGameData();
                            await LoadHandData();
                            StateHasChanged();
                        });
                        break;
                }
            });

            await hubConnection.StartAsync();
            
            // Join game room
            if (hubConnection.State == HubConnectionState.Connected)
            {
                await hubConnection.InvokeAsync("JoinRoom", RoomId);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR connection failed: {ex.Message}");
        }
    }

    private async Task LoadGameData()
    {
        try
        {
            var response = await Http.GetFromJsonAsync<ApiSuccess<RoomStatusSnapshot>>($"/api/room/{RoomId}");
            
            if (response?.Data != null)
            {
                gameData = response.Data;
                roomName = gameData.Name ?? $"Game {RoomId[..8]}";
                
                // Check if game has ended based on status
                if (gameData.Status == "Ended" || gameData.Status == "Finished")
                {
                    gameEnded = true;
                    pollingTimer?.Dispose(); // Stop polling when game ends
                }
                
                // Update phase from API response
                UpdateGamePhase(gameData.Phase);
                
                // Set current turn player (demo logic)
                if (gameData.Racers.Count > 0)
                {
                    currentTurnPlayer = gameData.CurrentTurnPlayerId;
                    isMyTurn = currentTurnPlayer == AuthService.PlayerId;
                }
                
                isLoading = false;
            }
            else
            {
                // Only set gameData to null if game hasn't ended
                // This prevents "Room Not Found" when game ends
                if (!gameEnded)
                {
                    gameData = null;
                }
                isLoading = false;
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load game data: {ex.Message}");
            // Only set gameData to null if game hasn't ended
            if (!gameEnded)
            {
                gameData = null;
            }
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void UpdateGamePhase(string phaseString)
    {
        var oldPhase = gamePhase;
        gamePhaseString = phaseString;
        
        // Try to parse the phase string to enum, fallback to default if parsing fails
        if (Enum.TryParse<Toko.Shared.Models.Phase>(phaseString, true, out var parsedPhase))
        {
            gamePhase = parsedPhase;
        }
        else
        {
            // Default fallback - don't throw, just use a safe default
            gamePhase = Toko.Shared.Models.Phase.CollectingCards;
            Console.WriteLine($"Unknown phase string: {phaseString}, using default CollectingCards");
        }
        
        // Reset parameter state when entering CollectingParams phase
        if (oldPhase != gamePhase && gamePhase == Phase.CollectingParams)
        {
            ResetParameterState();
        }
        
        // Reset discard selection when entering Discarding phase
        if (oldPhase != gamePhase && gamePhase == Phase.Discarding)
        {
            selectedDiscardCards.Clear();
        }
    }

    private void ToggleCardSelection(CardDto card)
    {
        if (!IsCardPlayable(card)) return;

        // Since only one card can be selected at a time, toggle selection
        if (selectedCard == card.Id)
        {
            selectedCard = "";
        }
        else
        {
            selectedCard = card.Id;
        }
    }

    private bool IsCardPlayable(CardDto card)
    {
        return isMyTurn && gamePhase == Phase.CollectingCards && card.Type != "Junk";
    }

    private void HandleCardClick(CardDto card)
    {
        if (gamePhase == Phase.CollectingCards)
        {
            ToggleCardSelection(card);
        }
        else if (gamePhase == Phase.CollectingParams && gameData?.CurrentTurnCardType == "Repair")
        {
            // In repair phase, only allow selecting Junk cards from hand
            if (card.Type == "Junk")
            {
                ToggleJunkCardSelection(card.Id);
            }
        }
        else if (gamePhase == Phase.Discarding && IsPlayerInDiscardPhase())
        {
            ToggleDiscardCardSelection(card.Id);
        }
    }

    private string GetCardSelectionClass(CardDto card)
    {
        var classes = new List<string>();
        
        if (gamePhase == Phase.CollectingCards)
        {
            if (selectedCard == card.Id)
                classes.Add("selected");
            
            if (IsCardPlayable(card))
                classes.Add("playable");
            else
                classes.Add("disabled");
        }
        else if (gamePhase == Phase.CollectingParams && gameData?.CurrentTurnCardType == "Repair")
        {
            // In repair phase, only Junk cards can be selected
            if (selectedJunkCards.Contains(card.Id))
                classes.Add("selected");
            
            if (card.Type == "Junk")
                classes.Add("playable");
            else
                classes.Add("disabled");
        }
        else if (gamePhase == Phase.Discarding && IsPlayerInDiscardPhase())
        {
            if (selectedDiscardCards.Contains(card.Id))
                classes.Add("selected");
            
            if (card.Type == "Junk")
                classes.Add("disabled");
            else
                classes.Add("playable");
        }
        else
        {
            classes.Add("disabled");
        }
        
        return string.Join(" ", classes);
    }

    private async Task PlaySelectedCard()
    {
        if (string.IsNullOrEmpty(selectedCard) || !isMyTurn) return;

        try
        {
            var request = new { CardId = selectedCard };
            await Http.PostAsJsonAsync($"/api/room/{RoomId}/submit-step-card", request);
            
            // Remove selected card from hand
            playerHand.RemoveAll(c => c.Id == selectedCard);
            selectedCard = "";
            
            // Add log entry
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, "You submitted a card."));
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to play card: {ex.Message}");
        }
    }

    private async Task DrawCards()
    {
        if (!isMyTurn) return;

        try
        {
            // Use the real API to draw cards
            var response = await Http.PostAsJsonAsync($"/api/room/{RoomId}/drawSkip", new { });
            
            if (response.IsSuccessStatusCode)
            {
                // Reload hand data after drawing cards
                await LoadHandData();
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, "You drew cards."));
                
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                Console.WriteLine($"Failed to draw cards: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to draw cards: {ex.Message}");
        }
    }

    private async Task ExecuteMove()
    {
        if (!isMyTurn || gamePhase != Phase.CollectingParams) return;

        try
        {
            // TODO: Implement real execution logic with API
            // For now, just add a log entry
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, "You executed your programmed moves."));
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to execute move: {ex.Message}");
        }
    }

    // Parameter collection methods
    private void SetMoveEffect(int effect)
    {
        moveEffect = effect;
    }

    private void SetChangeLaneEffect(int effect)
    {
        changeLaneEffect = effect;
    }

    private void ToggleJunkCardSelection(string cardId)
    {
        if (selectedJunkCards.Contains(cardId))
        {
            selectedJunkCards.Remove(cardId);
        }
        else
        {
            selectedJunkCards.Add(cardId);
        }
    }

    private bool IsParameterSubmissionReady()
    {
        if (!isMyTurn || gamePhase != Phase.CollectingParams) return false;
        
        return gameData?.CurrentTurnCardType switch
        {
            "Move" => moveEffect >= 1 && moveEffect <= 2,
            "ChangeLane" => changeLaneEffect == -1 || changeLaneEffect == 1,
            "Repair" => true, // Always ready for repair (can have empty selection)
            _ => false
        };
    }

    private async Task SubmitParameters()
    {
        if (!IsParameterSubmissionReady()) return;

        try
        {
            object execParameter = gameData?.CurrentTurnCardType switch
            {
                "Move" => new { Effect = moveEffect, DiscardedCardIds = new List<string>() },
                "ChangeLane" => new { Effect = changeLaneEffect, DiscardedCardIds = new List<string>() },
                "Repair" => new { Effect = -1, DiscardedCardIds = selectedJunkCards.ToList() },
                _ => throw new InvalidOperationException($"Unknown card type: {gameData?.CurrentTurnCardType}")
            };

            var request = new { ExecParameter = execParameter };
            var response = await Http.PostAsJsonAsync($"/api/room/{RoomId}/submit-exec-param", request);

            if (response.IsSuccessStatusCode)
            {
                // Create detailed log message based on card type
                var logMessage = gameData?.CurrentTurnCardType switch
                {
                    "Move" => $"You submitted Move parameters: distance {moveEffect}",
                    "ChangeLane" => $"You submitted ChangeLane parameters: direction {(changeLaneEffect == -1 ? "Left" : "Right")}",
                    "Repair" => $"You submitted Repair parameters: discarded {selectedJunkCards.Count} Junk cards",
                    _ => $"You submitted parameters for {gameData?.CurrentTurnCardType} card"
                };

                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, logMessage));
                
                // Reset parameter state
                ResetParameterState();
                
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Failed to submit parameters: {response.StatusCode} - {errorContent}");
                
                // Show error to user
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error submitting parameters: {response.StatusCode}"));
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to submit parameters: {ex.Message}");
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error submitting parameters: {ex.Message}"));
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ResetParameterState()
    {
        moveEffect = 1;
        changeLaneEffect = 1;
        selectedJunkCards.Clear();
    }

    // Discarding phase methods
    private bool IsPlayerInDiscardPhase()
    {
        var playerId = AuthService.PlayerId ?? "";
        var isInDiscardPhase = gamePhase == Phase.Discarding && 
                              gameData?.DiscardPendingPlayerIds?.Contains(playerId) == true;
        
        return isInDiscardPhase;
    }

    private bool HasJunkCardsSelected()
    {
        // Check if any selected cards are Junk cards
        return selectedDiscardCards.Any(cardId => 
            playerHand.Any(card => card.Id == cardId && card.Type == "Junk"));
    }

    private void ToggleDiscardCardSelection(string cardId)
    {
        // Find the card to check if it's a Junk card
        var card = playerHand.FirstOrDefault(c => c.Id == cardId);
        if (card == null || card.Type == "Junk")
        {
            return; // Cannot select Junk cards for discarding
        }

        if (selectedDiscardCards.Contains(cardId))
        {
            selectedDiscardCards.Remove(cardId);
        }
        else
        {
            selectedDiscardCards.Add(cardId);
        }
    }

    private async Task SubmitDiscardCards()
    {
        if (!IsPlayerInDiscardPhase()) return;

        try
        {
            var request = new { CardIds = selectedDiscardCards.ToList() };
            var response = await Http.PostAsJsonAsync($"/api/room/{RoomId}/discard-cards", request);

            if (response.IsSuccessStatusCode)
            {
                // Log the discard action
                var logMessage = selectedDiscardCards.Count > 0 
                    ? $"You discarded {selectedDiscardCards.Count} cards"
                    : "You chose not to discard any cards";
                
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, logMessage));
                
                // Clear selection
                selectedDiscardCards.Clear();
                
                // Reload hand data
                await LoadHandData();
                
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Failed to discard cards: {response.StatusCode} - {errorContent}");
                
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error discarding cards: {response.StatusCode}"));
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to discard cards: {ex.Message}");
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error discarding cards: {ex.Message}"));
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SkipDiscard()
    {
        if (!IsPlayerInDiscardPhase()) return;

        try
        {
            // Submit empty card list to skip discarding
            var request = new { CardIds = new List<string>() };
            var response = await Http.PostAsJsonAsync($"/api/room/{RoomId}/discard-cards", request);

            if (response.IsSuccessStatusCode)
            {
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, "You skipped discarding"));
                
                // Clear selection
                selectedDiscardCards.Clear();
                
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Failed to skip discard: {response.StatusCode} - {errorContent}");
                
                gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error skipping discard: {response.StatusCode}"));
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to skip discard: {ex.Message}");
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, $"Error skipping discard: {ex.Message}"));
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task EndTurn()
    {
        if (!isMyTurn) return;

        try
        {
            // TODO: Implement real end turn logic with API
            // For now, just add a log entry
            gameLogs.Add(new GameLogEntry(gameData?.CurrentRound ?? 1, "Turn ended."));
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to end turn: {ex.Message}");
        }
    }

    private async Task LeaveGame()
    {
        try
        {
            await Http.PostAsync($"/api/room/{RoomId}/leave", null);
            
            if (hubConnection?.State == HubConnectionState.Connected)
            {
                await hubConnection.InvokeAsync("LeaveRoom", RoomId);
            }
            
            Navigation.NavigateTo("/");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to leave game: {ex.Message}");
        }
    }

    private void ShowGameMenu()
    {
        // TODO: Implement game menu
        Console.WriteLine("Game menu clicked");
    }

    private void GoHome()
    {
        Navigation.NavigateTo("/");
    }

    private void ViewRoom()
    {
        Navigation.NavigateTo($"/room/{RoomId}");
    }

    private void ReviewGame()
    {
        // Close the game ended overlay and show the game state
        gameEnded = false;
        StateHasChanged();
    }

    // Helper methods
    private int GetPlayerPosition(string playerId)
    {
        // Get actual position from racer data
        if (gameData?.Racers == null) return 0;
        
        var racer = gameData.Racers.FirstOrDefault(r => r.Id == playerId);
        if (racer == null) return 0;
        
        // Calculate position based on Segment, Lane, and Tile
        // For now, use Segment as the primary position indicator
        return racer.Segment + 1;
    }

    private string GetPlayerName(string? playerId)
    {
        if (string.IsNullOrEmpty(playerId) || gameData?.Racers == null) return "Unknown";
        return gameData.Racers.FirstOrDefault(r => r.Id == playerId)?.Name ?? "Unknown";
    }

    private string GetPlayerInitials(string playerName)
    {
        var parts = playerName.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length >= 2)
            return $"{parts[0][0]}{parts[1][0]}".ToUpper();
        return playerName.Length >= 2 ? playerName[..2].ToUpper() : playerName.ToUpper();
    }

    private string GetPlayerColorClass(string playerId)
    {
        var index = gameData?.Racers?.FindIndex(r => r.Id == playerId) ?? 0;
        var colors = new[] { "color-red", "color-blue", "color-green", "color-yellow" };
        return colors[index % colors.Length];
    }

    private List<RacerStatus> GetPlayersAtPosition(int position)
    {
        if (gameData?.Racers == null) return new List<RacerStatus>();
        
        // Return racers at the specified segment position
        return gameData.Racers.Where(r => r.Segment == position).ToList();
    }

    private string GetCardValue(string cardType)
    {
        return cardType switch
        {
            "Move" => "M",
            "ChangeLane" => "L",
            "Junk" => "J",
            "Repair" => "R",
            _ => "?"
        };
    }

    // Card overlay helper methods
    private bool ShouldShowCardDisabledOverlay(CardDto card)
    {
        if (gamePhase == Phase.CollectingCards && card.Type == "Junk")
        {
            return true; // Junk cards cannot be played in normal card submission
        }
        else if (gamePhase == Phase.CollectingParams && gameData?.CurrentTurnCardType == "Repair")
        {
            return card.Type != "Junk"; // Only Junk cards can be selected in repair phase
        }
        else if (gamePhase == Phase.Discarding && IsPlayerInDiscardPhase() && card.Type == "Junk")
        {
            return true; // Junk cards cannot be discarded
        }
        
        return false;
    }

    private string GetCardDisabledMessage(CardDto card)
    {
        if (gamePhase == Phase.CollectingCards && card.Type == "Junk")
        {
            return "Cannot play";
        }
        else if (gamePhase == Phase.CollectingParams && gameData?.CurrentTurnCardType == "Repair")
        {
            return card.Type != "Junk" ? "Cannot select" : "";
        }
        else if (gamePhase == Phase.Discarding && IsPlayerInDiscardPhase() && card.Type == "Junk")
        {
            return "Cannot discard";
        }
        
        return "Disabled";
    }

    public async ValueTask DisposeAsync()
    {
        pollingTimer?.Dispose();
        
        if (hubConnection != null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    // Helper classes
    private record GameLogEntry(int Turn, string Message);
}
